"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[536],{9551:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>d});var o=n(7462),i=(n(7294),n(3905)),a=n(814),r=n(4088);const l={sidebar_position:3},s="Olink",p={unversionedId:"features/olink",id:"features/olink",title:"Olink",description:"This feature provides a client and a server adapters for your interfaces for the ObjectLink protocol. You can connect to different technologies (check out all of our templates). Or you can use it for simulation.",source:"@site/docs/features/olink.md",sourceDirName:"features",slug:"/features/olink",permalink:"/template-qtcpp/features/olink",draft:!1,editUrl:"https://github.com/apigear-io/template-qtcpp/edit/main/docs/features/olink.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1678197045,formattedLastUpdatedAt:"Mar 7, 2023",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Stubs",permalink:"/template-qtcpp/features/stubs"},next:{title:"Monitor",permalink:"/template-qtcpp/features/monitor"}},c={},d=[{value:"Apigear ObjectLink protocol and ObjectLink core library",id:"apigear-objectlink-protocol-and-objectlink-core-library",level:3},{value:"File overview for module",id:"file-overview-for-module",level:2},{value:"Qt apigear - The Network Layer",id:"qt-apigear---the-network-layer",level:3},{value:"Olink Client Adapter",id:"olink-client-adapter",level:3},{value:"Properties",id:"properties",level:4},{value:"Operations",id:"operations",level:4},{value:"Signals",id:"signals",level:4},{value:"How to set up working <code>OLinkHello</code>",id:"how-to-set-up-working-olinkhello",level:4},{value:"Olink Server Adapter",id:"olink-server-adapter",level:3},{value:"Properties",id:"properties-1",level:4},{value:"Operations",id:"operations-1",level:4},{value:"Signals",id:"signals-1",level:4},{value:"How to set up working <code>OLinkHelloAdapter</code>",id:"how-to-set-up-working-olinkhelloadapter",level:4},{value:"Simulation",id:"simulation",level:2}],k={toc:d},h="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,o.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"olink"},"Olink"),(0,i.kt)("p",null," This feature provides a client and a server adapters for your interfaces for the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/objectlink/"},"ObjectLink")," protocol. You can connect to different technologies (check out all of our templates). Or you can use it for simulation."),(0,i.kt)("h3",{id:"apigear-objectlink-protocol-and-objectlink-core-library"},"Apigear ObjectLink protocol and ObjectLink core library"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/objectlink/"},"ObjectLink")," protocol is a lightweight protocol for the Objects described with an interface. It allows connecting a client object with a server object, as well as operations like: remote property change request (client) or notifications on property changed (server), informs about signal emission (server) and allows requesting a call of a method (client) and giving a response to the its outcome (server)."),(0,i.kt)("p",null,"The Olink feature for your interface uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apigear-io/objectlink-core-cpp"},"ObjectLink core"),", common for cpp based templates library. Provided CMakeLists already contain all the dependencies, so you don't have to add it manually."),(0,i.kt)("p",null,"The library provides network independent abstraction layer for handling the protocol. It codes and decodes the messages and routes to proper objects kept in its registry.\nYou don't need to interact with the library much for proper work of the feature. All you need to do is instantiate the registries (for client and/or server) and pass them to network layer objects in ",(0,i.kt)("a",{parentName:"p",href:"olink#qt-apigear---the-network-layer"},"qt apigear library")," "),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"}," In this library we use STL classes in public interfaces.\nWe assume that this library is built from source (configuration provided by generated CMakeLists).\nOtherwise, it has to be ensured that your build configuration matches the library build configuration.")),(0,i.kt)("h2",{id:"file-overview-for-module"},"File overview for module"),(0,i.kt)("p",null," With an example  API"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hello World API (click to expand)"),(0,i.kt)(a.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},r.Z)),(0,i.kt)("p",null,"The following file structure will be generated, each file will be explained with feature detailed description."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:"{4,16}","{4,16}":!0},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2monitor\n \u2503 \u2523 \ud83d\udcc2olink\n \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2523 \ud83d\udcdcolinkclient.cpp\n \u2503 \u2503 \u2523 \ud83d\udcdcolinkclient.h\n \u2503 \u2503 \u2523 \ud83d\udcdcolinkhost.cpp\n \u2503 \u2503 \u2523 \ud83d\udcdcolinkhost.h\n \u2503 \u2503 \u2523 \ud83d\udcdcolinkremote.cpp\n \u2503 \u2503 \u2517 \ud83d\udcdcolinkremote.h\n \u2503 ...\n \u2523 \ud83d\udcc2qt_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2io_world\n \u2503 \u2503 \u2523 \ud83d\udcc2api\n \u2503 \u2503 \u2523 \ud83d\udcc2implementation\n \u2503 \u2503 \u2523 \ud83d\udcc2olink\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcolinkfactory.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcolinkfactory.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcolinkhello.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcolinkhello.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcolinkhelloadapter.cpp\n \u2503 \u2503 \u2503 \u2517 \ud83d\udcdcolinkhelloadapter.h\n ...\n")),(0,i.kt)("h3",{id:"qt-apigear---the-network-layer"},"Qt apigear - The Network Layer"),(0,i.kt)("p",null,"Together with the olink feature (or monitor feature) you'll see additional folder generated, the \ud83d\udcc2hello-world/\ud83d\udcc2apigear. The \ud83d\udcc2olink subfolder contains objects that implement a network layer (based on QtWebSocket library) for the ObjectLink protocol. Those are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"OlinkClient - the client, that serves your ",(0,i.kt)("a",{parentName:"li",href:"olink#Olink-Client-Adapter"},"interface client adapters"),".\nThe class is responsible for network connection for ObjectLink client side. It uses ObjectLink core library for handling messages according to ObjectLink protocol. Handles linking and unlinking with remote service for the sink added by user, with regard to the connection state. All the messages dedicated to your sink will end there without any of your actions. Also the OlinkClient holds a message queue for messages during disconnected time."),(0,i.kt)("li",{parentName:"ul"},"OlinkHost (and a helper class OlinkRemote- the server, which hosts your services exposed to network through the ",(0,i.kt)("a",{parentName:"li",href:"olink#Olink-Server-Adapter"},"interface server adapters"),". The class is responsible to set up the server and manage connections requested by clients. It uses ObjectLink core library for handling messages according to ObjectLink protocol. All incoming messages will be translated to calls and routed to your local object.")),(0,i.kt)("h3",{id:"olink-client-adapter"},"Olink Client Adapter"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcolinkhello.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcolinkhello.cpp")," contain the olink client adapter for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class OLinkHello : public AbstractHello, public IObjectSink\n")),(0,i.kt)("p",null,"It inherits two interfaces: ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractHello")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"IObjectSink"),", which comes from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apigear-io/objectlink-core-cpp"},"ObjectLink core"),". Apart from setting up and tear down of your ",(0,i.kt)("inlineCode",{parentName:"p"},"OlinkHello")," object, you should use it as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," Object only.\nThe IObjectSink interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="part of OlinkHello"',title:'"part',of:!0,'OlinkHello"':!0},"...\n    std::string olinkObjectName() override;\n    void olinkOnSignal(const std::string& signalId, const nlohmann::json& args) override;\n    void olinkOnPropertyChanged(const std::string& propertyId, const nlohmann::json& value) override;\n    void olinkOnInit(const std::string& objectId, const nlohmann::json& props, ::ApiGear::ObjectLink::IClientNode *node) override;\n    void olinkOnRelease() override;\n...\n")),(0,i.kt)("p",null,"is necessary for handling incoming messages from the server side and is used by a ",(0,i.kt)("inlineCode",{parentName:"p"},"OlinkClient")," (",(0,i.kt)("a",{parentName:"p",href:"olink#Qt-apigear---The-Network-Layer"},"Qt Apigear Olink lib"),"), after you link your object to it. You don't need to perform any additional actions, the object ",(0,i.kt)("inlineCode",{parentName:"p"},"OLinkHello")," (if the server side is up) will communicate with the server transparently for you, and you can focus on just using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface."),(0,i.kt)("h4",{id:"properties"},"Properties"),(0,i.kt)("p",null,"The property getters (here ",(0,i.kt)("inlineCode",{parentName:"p"},"Message last()")," ) return immediately the locally stored last received value from server.\nThe property setter (here ",(0,i.kt)("inlineCode",{parentName:"p"},"void setLast(const Message& last)")," ) requests setting a value on server side.\nYou can connect to a property changed signals (here ",(0,i.kt)("inlineCode",{parentName:"p"},"void lastChanged(const Message& last)")," )\nWhen a your OlinkHello client receives the olinkOnPropertyChanged, a target property (here ",(0,i.kt)("inlineCode",{parentName:"p"},"last"),") is updated locally and a signal that property has changed is emitted ( here ",(0,i.kt)("inlineCode",{parentName:"p"},"void lastChanged(const Message& last)"),"."),(0,i.kt)("h4",{id:"operations"},"Operations"),(0,i.kt)("p",null,"The non-void operations have additionally the async version, which is called by the normal one.\nThe async version sends an invoke operation request to a server."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="part of OlinkHello"',title:'"part',of:!0,'OlinkHello"':!0},"...\n    int say(const Message& msg, When::WhenEnum when) override;\n    QtPromise::QPromise<int> sayAsync(const Message& msg, When::WhenEnum when);\n...\n")),(0,i.kt)("p",null,"so calling ",(0,i.kt)("inlineCode",{parentName:"p"},"myOlinkHelloInstance.say(myWhen)")," implements execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"sayAsync")," and waits for the result. Have in mind that this is a blocking operation."),(0,i.kt)("h4",{id:"signals"},"Signals"),(0,i.kt)("p",null,"You should not emit any signals from a client.\nYou can connect to any signals offered by your interface (here ",(0,i.kt)("inlineCode",{parentName:"p"},"void justSaid(const Message& msg)")," )\nWhen a your OlinkHello client receives the olinkOnSignal, a signal (here ",(0,i.kt)("inlineCode",{parentName:"p"},"justSaid"),") is emitted."),(0,i.kt)("h4",{id:"how-to-set-up-working-olinkhello"},"How to set up working ",(0,i.kt)("inlineCode",{parentName:"h4"},"OLinkHello")),(0,i.kt)("p",null,"As mentioned earlier you need a network layer, here provided by a ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::OLinkClient")," which also contains the protocol handling ",(0,i.kt)("inlineCode",{parentName:"p"},"ClientNode"),". All you need to do is give it a global ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::ClientRegistry"),", request connecting to host when it is convenient for you and then add your ",(0,i.kt)("inlineCode",{parentName:"p"},"OlinkHello"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'    // Create a global registry.\n    ApiGear::ObjectLink::ClientRegistry registry;\n    // Create a client and make a connection\n    ApiGear::ObjectLink::OLinkClient client(registry);\n    client.connectToHost(QUrl("ws://127.0.0.1:8182"));\n\n    // Create your service client and request it linking, which will try to connect with a server side for this object.\n    auto ioWorldHello = std::make_shared<io_world::OLinkHello>();\n    client.linkObjectSource(ioWorldHello);\n\n    // use your ioWorldHello as it was Hello implementation\n    ioWorldHello.say(someWhen);\n    auto lastMessage = ioWorldHello->last();\n    ioWorldHello->setLast(someMessage);\n    ioWorldHello->connect(ioWorldHello.get(), &io_world::AbstractHello::justSaid, *otherObject, &SomeJustSaidUser::handleJustSaid);\n\n    // remember to unlink your object if you won\'t use it anymore.\n    client.unlinkObjectSource(ioWorldHello->olinkObjectName());\n')),(0,i.kt)("h3",{id:"olink-server-adapter"},"Olink Server Adapter"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcolinkhelloadapter.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcolinkhelloadapter.h")," contain the olink server adapter for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class OLinkHelloAdapter : public QObject, public ApiGear::ObjectLink::IObjectSource\n    explicit OLinkHelloAdapter(ApiGear::ObjectLink::RemoteRegistry& registry, AbstractHello* impl);\n")),(0,i.kt)("p",null,"It inherits a ",(0,i.kt)("inlineCode",{parentName:"p"},"IObjectSource")," interface, which comes from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apigear-io/objectlink-core-cpp"},"ObjectLink core"),". And wraps your ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object with a functionality to expose it as a network service through the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/objectlink/"},"ObjectLink")," protocol. When creating the ",(0,i.kt)("inlineCode",{parentName:"p"},"OLinkHelloAdapter")," you need to provide your local ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractHello")," object, which will be used by clients, through the adapter class.\nThe IObjectSource interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="part of OLinkHelloAdapter"',title:'"part',of:!0,'OLinkHelloAdapter"':!0},"...\n    std::string olinkObjectName() override;\n    nlohmann::json olinkInvoke(const std::string& methodId, const nlohmann::json& args) override;\n    void olinkSetProperty(const std::string& propertyId, const nlohmann::json& value) override;\n    void olinkLinked(const std::string& objectId, IRemoteNode* node) override;\n    void olinkUnlinked(const std::string& objectId) override;\n    nlohmann::json olinkCollectProperties() override;\n...\n")),(0,i.kt)("p",null,"is necessary for handling incoming messages from the server side and is used by a ",(0,i.kt)("inlineCode",{parentName:"p"},"OlinkRemote")," (",(0,i.kt)("a",{parentName:"p",href:"olink#Qt-apigear---The-Network-Layer"},"Qt Apigear Olink lib"),"), after you link your object to it, and a client connects. You don't need to perform any additional actions, the object ",(0,i.kt)("inlineCode",{parentName:"p"},"OLinkHelloAdapter")," will communicate with connected clients transparently for you, and you can focus on just using your ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object."),(0,i.kt)("h4",{id:"properties-1"},"Properties"),(0,i.kt)("p",null,"Each time a property changed signals (here ",(0,i.kt)("inlineCode",{parentName:"p"},"void lastChanged(const Message& last)")," ) is emitted, a message is sent to all connected clients with information, which property changed to which value. This may occur either when you change a property directly on your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object, or when a change property request message is received by the ",(0,i.kt)("inlineCode",{parentName:"p"},"OLinkHelloAdapter"),", which applies the property on your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object."),(0,i.kt)("h4",{id:"operations-1"},"Operations"),(0,i.kt)("p",null,"The operations invocation which came from the clients through the network will be performed on your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," object. Messages are served one by one, so clients won't be using it in a multithreaded manner (unless your using the OLinkHelloAdapter and your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," from different threads) but non-reentrancy cannot be promised.\nThe result of the operation (if any) will be returned only to a caller, not all clients."),(0,i.kt)("h4",{id:"signals-1"},"Signals"),(0,i.kt)("p",null,"All the signals emitted by your local ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," objects are forwarded to all connected clients."),(0,i.kt)("h4",{id:"how-to-set-up-working-olinkhelloadapter"},"How to set up working ",(0,i.kt)("inlineCode",{parentName:"h4"},"OLinkHelloAdapter")),(0,i.kt)("p",null,"As mentioned earlier you need a network layer, here provided by a ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::OLinkHost")," (The ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::OLinkRemote")," objects are created automatically per connection) which also contains the protocol handling ",(0,i.kt)("inlineCode",{parentName:"p"},"RemoteNode"),"s. All you need to do is give  a global ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::RemoteRegistry")," with your ",(0,i.kt)("inlineCode",{parentName:"p"},"OLinkHelloAdapter")," in it to ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::OLinkHost"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'\n    // Prepare the registry, the server, and an object which you want to expose.\n    ApiGear::ObjectLink::RemoteRegistry registry;\n    ApiGear::ObjectLink::OLinkHost server(registry);\n    server.listen("localhost", 8182);\n    auto ioWorldHello = std::make_shared<io_world::Hello>();\n\n    // Create your OLinkHelloAdapter and add it to registry.\n    auto ioWorldOlinkHelloService = std::make_shared<io_world::OLinkHelloAdapter>(registry, &ioWorldHello);\n    registry.addSource(ioWorldOlinkHelloService);\n\n    // use your ioWorldHello as it was Hello implementation\n    ioWorldHello.say(someWhen);\n    auto lastMessage = ioWorldHello->last();\n    ioWorldHello->setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value.\n    ioWorldHello->connect(ioWorldHello.get(), &io_world::AbstractHello::justSaid, *otherObject, &SomeJustSaidUser::handleJustSaid);\n\n    // Remember to remove your ioWorldOlinkHelloService after you finish using it.\n    registry.removeSource(ioWorldOlinkHelloService->olinkObjectName());\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\n### Olink Factory - for QML usage\nFiles `\ud83d\udcdcolinkfactory.h`  and `\ud83d\udcdcolinkfactory.cpp` contain the OLinkFactory which creates the OlinkClient versions of your interfaces.\nIn our example it will produce only `Hello` interfaces:\n```cpp\n std::shared_ptr<AbstractHello> createHello(QObject *parent = nullptr) override;\n")),(0,i.kt)("p",null,"The factory is necessary when you want to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello")," client directly in QML. For that, you will choose the ",(0,i.kt)("a",{parentName:"p",href:"api#qml-wrappers"},"QML version")," of your API to which you need provide OlinkClient backend - this is what the factory is for. See more details ",(0,i.kt)("a",{parentName:"p",href:"api#providing-backend-to-qml-wrapper"},"on providing backend to QML wrapper")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'    // Prepare Factory before app is created.\n    ApiGear::ObjectLink::ClientRegistry client_registry;\n    ApiGear::ObjectLink::OLinkClient client(client_registry);\n    io_world::OLinkFactory io_worldOlinkFactory(client);\n    io_world::ApiFactory::set(&io_worldOlinkFactory);\n    ...\n    // Connect the client - all qml olink clients will be linked if the server services are already up.\n    client.connectToHost(QUrl("ws://127.0.0.1:8182"));\n')),(0,i.kt)("p",null,"The factory uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"ApiGear::ObjectLink::OLinkClient")," and links the objects when they are created. You don't have to perform any other actions, just use your qml version of ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-qml"},"...\nimport io_world 1.0\n\nApplicationWindow {\n...\n            Button {\n            width: 80\n            height: 80\n            text: qmlIoWorldHello.last.content\n            onClicked: {\n                qmlIoWorldHello.say(someMessage, someWhen)\n            }\n        }\n    IoWorldHello { id: qmlIoWorldHello }\n...\n}\n")),(0,i.kt)("h2",{id:"simulation"},"Simulation"),(0,i.kt)("p",null," The simulation can be used to test, demonstrate or develop applications without the need to have the actual service available.\nThe simulation server is integrated into ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/docs/category/desktop-studio"},"ApiGear studio"),". On your code side you need to use the OlinkClient backend version: either instance on ",(0,i.kt)("a",{parentName:"p",href:"olink#olink-client-adapter"},"cpp side")," or ",(0,i.kt)("a",{parentName:"p",href:"olink#olink-factory---for-qml-usage"},"qml version")," and connect to a same url and port that you configure in the ApiGear studio."),(0,i.kt)("p",null," For simulating you will use ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/docs/advanced/simulation/scenario"},"simulation scenarios")," They allow to define sequences of actions which can be triggered by an operation call or by name. The actions can change the property values of the service or emit signals. The scenarios can be written using a YAML schema."),(0,i.kt)("p",null,"See more on ",(0,i.kt)("a",{parentName:"p",href:"https://docs.apigear.io/docs/advanced/simulation/intro"},"simulation"),"."))}u.isMDXComponent=!0}}]);