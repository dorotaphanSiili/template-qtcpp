"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[640],{7926:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));n(814);const s={sidebar_position:5},l="Qml Plugin",o={unversionedId:"features/qmlplugin",id:"features/qmlplugin",title:"Qml Plugin",description:"You may want to use a Qml plugin for your module. This may be handy when you don't want to register structs (with qRegisterMetaType) or the interfaces (with qmlRegisterType) on compile time, in the main. Instead you can use the structs and the interfaces as an external module.",source:"@site/docs/features/qmlplugin.md",sourceDirName:"features",slug:"/features/qmlplugin",permalink:"/template-qtcpp/features/qmlplugin",draft:!1,editUrl:"https://github.com/apigear-io/template-qtcpp/edit/main/docs/features/qmlplugin.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1678703028,formattedLastUpdatedAt:"Mar 13, 2023",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docsSidebar",previous:{title:"Monitor",permalink:"/template-qtcpp/features/monitor"},next:{title:"Http client",permalink:"/template-qtcpp/features/http"}},r={},p=[],u={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"qml-plugin"},"Qml Plugin"),(0,i.kt)("p",null,"You may want to use a ",(0,i.kt)("a",{parentName:"p",href:"https://doc.qt.io/qtcreator/creator-qml-modules-with-plugins.html"},"Qml plugin")," for your module. This may be handy when you don't want to register structs (with ",(0,i.kt)("inlineCode",{parentName:"p"},"qRegisterMetaType"),") or the interfaces (with ",(0,i.kt)("inlineCode",{parentName:"p"},"qmlRegisterType"),") on compile time, in the main. Instead you can use the structs and the interfaces as an external module."),(0,i.kt)("p",null,"The plugin registers all the types and all you have to do is just use it in your CMakeList.\nFor the qt 5.15 you  you should add a line to your application CMakeLists.txt"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'set(QML_IMPORT_PATH  ${PLUGIN_BINARY_PATH} CACHE STRING "" FORCE)\nset(QML2_IMPORT_PATH  ${PLUGIN_BINARY_PATH} CACHE STRING "" FORCE)\n')),(0,i.kt)("p",null,"usually the ",(0,i.kt)("inlineCode",{parentName:"p"},"${PLUGIN_BINARY_PATH}")," is somewhere in your ",(0,i.kt)("inlineCode",{parentName:"p"},"CMAKE_BINARY_DIR")," and ends with ",(0,i.kt)("inlineCode",{parentName:"p"},"imports")," folder"),(0,i.kt)("p",null,"in our example code we set it to simplest combination of those two. We define a variable in main CMakeLists.txt in case of many modules, the plugins will end in same directory"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:'language-title="main',metastring:'CMakeLists.txt"','CMakeLists.txt"':!0},'set(IMPORTS_PATH "${CMAKE_BINARY_DIR}/imports" CACHE STRING "Path where the plugins are deployed")\n')),(0,i.kt)("p",null,"and then in each plugin we just use it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:'language-title="plugin',metastring:'CMakeLists.txt"','CMakeLists.txt"':!0},"set(OUTPUT_PATH ${IMPORTS_PATH}/io/world)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"/io/world")," is the module name"),(0,i.kt)("p",null,"When building and running with ",(0,i.kt)("em",{parentName:"p"},"qt creator")," you may need to add ",(0,i.kt)("inlineCode",{parentName:"p"},"QML_IMPORT_PATH")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"QML2_IMPORT_PATH")," also for run environment project settings, even if the settings claim to use build environment variables."))}d.isMDXComponent=!0}}]);