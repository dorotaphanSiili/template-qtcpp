"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[596],{3970:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>p,toc:()=>d});var n=a(7462),i=(a(7294),a(3905)),s=a(814),o=a(4088);const r={sidebar_position:2},l="Stubs",p={unversionedId:"features/stubs",id:"features/stubs",title:"Stubs",description:"The feature stubs adds a semi-featured starting point for your implementation. What you receive is:",source:"@site/docs/features/stubs.md",sourceDirName:"features",slug:"/features/stubs",permalink:"/template-qtcpp/features/stubs",draft:!1,editUrl:"https://github.com/apigear-io/template-qtcpp/edit/main/docs/features/stubs.md",tags:[],version:"current",lastUpdatedBy:"dphan10",lastUpdatedAt:1677823995,formattedLastUpdatedAt:"Mar 3, 2023",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"API",permalink:"/template-qtcpp/features/api"},next:{title:"Olink",permalink:"/template-qtcpp/features/olink"}},m={},d=[{value:"File overview for module",id:"file-overview-for-module",level:3},{value:"The Stub",id:"the-stub",level:3},{value:"Factory",id:"factory",level:3},{value:"Test",id:"test",level:3}],u={toc:d},c="wrapper";function h(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"stubs"},"Stubs"),(0,i.kt)("p",null,"The feature ",(0,i.kt)("inlineCode",{parentName:"p"},"stubs")," adds a semi-featured starting point for your implementation. What you receive is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"implementation stubs for your Interfaces."),(0,i.kt)("li",{parentName:"ul"},"the factory, that produces this implementation stubs (for QmlWrapper)"),(0,i.kt)("li",{parentName:"ul"},"set up for tests.")),(0,i.kt)("h3",{id:"file-overview-for-module"},"File overview for module"),(0,i.kt)("p",null,"With an example API"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hello World API (click to expand)"),(0,i.kt)(s.Z,{language:"yaml",showLineNumbers:!0,mdxType:"CodeBlock"},o.Z)),(0,i.kt)("p",null,"The following file structure will be generated, each file will be explained with feature detailed description."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:"{8}","{8}":!0},"\ud83d\udcc2hello-world\n \u2523 \ud83d\udcc2apigear\n \u2523 \ud83d\udcc2qt_hello_world\n \u2503 \u2523 \ud83d\udcc2apigear\n \u2503 \u2523 \ud83d\udcc2examples\n \u2503 \u2523 \ud83d\udcc2io_world\n \u2503 \u2503 \u2523 \ud83d\udcc2api\n \u2503 \u2503 \u2523 \ud83d\udcc2implementation\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcc2tests\n \u2503 \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2503 \u2503 \u2523 \ud83d\udcdctest_hello.cpp\n \u2503 \u2503 \u2503 \u2503 \u2517 \ud83d\udcdctest_hello.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcCMakeLists.txt\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcfactory.cpp\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdcfactory.h\n \u2503 \u2503 \u2503 \u2523 \ud83d\udcdchello.cpp\n \u2503 \u2503 \u2503 \u2517 \ud83d\udcdchello.h\n ...\n")),(0,i.kt)("h3",{id:"the-stub"},"The Stub"),(0,i.kt)("p",null,"Files ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchello.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdchello.cpp")," contain the implementation of the interface. For each interface we generate the pair of ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcinterface_name.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcinterface_name.cpp"),"."),(0,i.kt)("p",null,"The implementation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"inherits the abstract base class ",(0,i.kt)("inlineCode",{parentName:"li"},"AbstractHello")),(0,i.kt)("li",{parentName:"ul"},"adds the properties of interface as a private class members - here ",(0,i.kt)("inlineCode",{parentName:"li"},"Message m_last")),(0,i.kt)("li",{parentName:"ul"},"initializes them with default values in ctor."),(0,i.kt)("li",{parentName:"ul"},"defines getters and setters for each property"),(0,i.kt)("li",{parentName:"ul"},"provides empty implementation of operation.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"For all stubs we generate the import/export statements - here IO_WORLD_IMPL_EXPORT.")),(0,i.kt)("h3",{id:"factory"},"Factory"),(0,i.kt)("p",null,"Factory of stub is defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcfactory.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdcfactory.cpp"),"\nThis factory is necessary, when you wan't to provide this stub implementation to the Qml Wrapper.\nSee ",(0,i.kt)("a",{parentName:"p",href:"/template-qtcpp/features/api#providing-backend-to-qml-wrapper"},"this")," api section for full information."),(0,i.kt)("p",null,"Also have in mind, that using this version of the pair factory - stub you will not have any handle to interact with a created stub from code. Only changes and interaction will be possible from QML. You could create your version of factory which also registers the objects to some kind of global registry, this way you'd be able to also use it from code."),(0,i.kt)("h3",{id:"test"},"Test"),(0,i.kt)("p",null,"For each interface we provide a template for your tests: pair of ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdctest_hello.h")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud83d\udcdctest_hello.cpp")," files with a test class for the interface.\nIt contains 3 kind of init methods: before each test cases is executed, before first test case is executed and one to create a global data table for tests; For clean up there are 2 methods: one called after each test and one called after last test case is called.\nThere are also slots - initial dummy tests, one for each operation and property."))}h.isMDXComponent=!0},4088:(e,t,a)=>{a.d(t,{Z:()=>n});const n='schema: apigear.module/1.0\nname: io.world\nversion: "1.0"\n\ninterfaces:\n  - name: Hello\n    properties:\n      - { name: last, type: Message }\n    operations:\n      - name: say\n        params:\n          - { name: msg, type: Message }\n          - { name: when, type: When }\n        return:\n          type: int\n    signals:\n      - name: justSaid\n        params:\n          - { name: msg, type: Message }\nenums:\n  - name: When\n    members:\n      - { name: Now, value: 0 }\n      - { name: Soon, value: 1 }\n      - { name: Never, value: 2 }\nstructs:\n  - name: Message\n    fields:\n      - { name: content, type: string }\n'}}]);